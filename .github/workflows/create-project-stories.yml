name: Create GitHub Project Stories

on:
  push:
    branches:
      - main
    paths:
      - 'stories/**'

jobs:
  create-stories:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          
      - name: Get changed story files
        id: changed-files
        uses: tj-actions/changed-files@v45
        with:
          files: |
            stories/**/*.md
          separator: " "
          
      - name: Debug changed files info
        run: |
          echo "[DEBUG] Any changed files: ${{ steps.changed-files.outputs.any_changed }}" >> create-project-stories.log
          echo "[DEBUG] All changed files: ${{ steps.changed-files.outputs.all_changed_files }}" >> create-project-stories.log
          echo "[DEBUG] Added files: ${{ steps.changed-files.outputs.added_files }}" >> create-project-stories.log
          echo "[DEBUG] Modified files: ${{ steps.changed-files.outputs.modified_files }}" >> create-project-stories.log
          echo "[DEBUG] Removed files: ${{ steps.changed-files.outputs.removed_files }}" >> create-project-stories.log
          
      - name: Prepare log file
        run: |
          echo "Create GitHub Project Stories workflow started at $(date)" > create-project-stories.log
          echo "Commit SHA: ${{ github.sha }}" >> create-project-stories.log
          echo "Ref: ${{ github.ref }}" >> create-project-stories.log
          echo "Event name: ${{ github.event_name }}" >> create-project-stories.log
          echo "Any changed: ${{ steps.changed-files.outputs.any_changed }}" >> create-project-stories.log
          echo "Changed files: ${{ steps.changed-files.outputs.all_changed_files }}" >> create-project-stories.log
          
      - name: List stories directory
        run: |
          echo "[DEBUG] Listing stories directory contents:" >> create-project-stories.log
          ls -la stories/ >> create-project-stories.log 2>&1 || echo "[DEBUG] stories directory does not exist" >> create-project-stories.log
          
      - name: Create GitHub Project Stories
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
          PROJECT_ID: ${{ secrets.PROJECT_ID }}
        run: |
          echo "[DEBUG] Starting project item creation process at $(date)" >> create-project-stories.log
          echo "[DEBUG] Project ID: $PROJECT_ID" >> create-project-stories.log
          echo "[DEBUG] Changed files: ${{ steps.changed-files.outputs.all_changed_files }}" >> create-project-stories.log
          
          # Check if any story files changed
          CHANGED_FILES_OUTPUT="${{ steps.changed-files.outputs.all_changed_files }}"
          
          if [ -z "$CHANGED_FILES_OUTPUT" ] || [ "${{ steps.changed-files.outputs.any_changed }}" != "true" ]; then
            echo "[INFO] No changed files detected, processing all story files" >> create-project-stories.log
            ALL_STORY_FILES=$(find stories -name "*.md" -type f 2>/dev/null | tr '\n' ' ' | sed 's/ $//')
            echo "[DEBUG] All story files: $ALL_STORY_FILES" >> create-project-stories.log
            export CHANGED_FILES="$ALL_STORY_FILES"
          else
            echo "[INFO] Changed files detected: $CHANGED_FILES_OUTPUT" >> create-project-stories.log
            export CHANGED_FILES="$CHANGED_FILES_OUTPUT"
          fi
          
          echo "[DEBUG] Final CHANGED_FILES: $CHANGED_FILES" >> create-project-stories.log
          
          # Prepare artifacts directory first
          mkdir -p ./artifacts
          
          # Install required dependencies
          echo "[DEBUG] Installing dependencies" >> create-project-stories.log
          npm install marked graphql-request graphql >> create-project-stories.log 2>&1
          
          # Create a script to parse markdown files and create/update GitHub Project items
          cat > create-project-items.cjs << 'EOF'
          const fs = require('fs');
          const { marked } = require('marked');
          const { GraphQLClient, gql } = require('graphql-request');
          
          // Function to parse story markdown file
          function parseStoryFile(filePath) {
            console.log(`[parse] start file: ${filePath}`);
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            
            let title = '';
            let description = '';
            let acceptanceCriteria = [];
            let storyId = '';
            
            // Extract story ID
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].startsWith('### Story ID')) {
                storyId = lines[i + 1].trim();
                console.log(`[parse] found Story ID: ${storyId}`);
                break;
              }
            }
            
            // Extract title (assumed to be the first H2 header)
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].startsWith('## Story: ')) {
                title = lines[i].substring(10).trim();
                console.log(`[parse] found title: ${title}`);
                break;
              }
            }
            
            // Extract description (text between Description header and next header)
            let inDescription = false;
            let inAcceptanceCriteria = false;
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              
              if (line.startsWith('### Description')) {
                inDescription = true;
                inAcceptanceCriteria = false;
                continue;
              } else if (line.startsWith('### Acceptance Criteria')) {
                inDescription = false;
                inAcceptanceCriteria = true;
                continue;
              } else if (line.startsWith('### ') && (inDescription || inAcceptanceCriteria)) {
                inDescription = false;
                inAcceptanceCriteria = false;
                continue;
              }
              
              if (inDescription && line !== '') {
                description += line + ' ';
              }
              
              if (inAcceptanceCriteria && line.startsWith('- ')) {
                acceptanceCriteria.push(line.substring(2));
              }
            }
            
            // If no story ID found, generate one from file name
            if (!storyId) {
              const fileName = filePath.split('/').pop().replace('.md', '');
              const repositoryName = process.env.GITHUB_REPOSITORY ? process.env.GITHUB_REPOSITORY.split('/')[1] : 'nzlouis-property-ai';
              storyId = `${repositoryName}-${fileName}`;
            }
            
            console.log(`[parse] AC count: ${acceptanceCriteria.length}`);
            console.log(`[parse] summary: id=${storyId} title="${title}" descLen=${description.trim().length}`);
            return {
              storyId,
              title,
              description: description.trim(),
              acceptanceCriteria
            };
          }
          
          // Function to check if an item with the same story ID already exists
          async function findExistingItem(client, projectId, storyId) {
            console.log(`[find] Checking for existing item with storyId: ${storyId}`);
            
            const query = gql`
              query($projectId: ID!, $first: Int!, $after: String) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: $first, after: $after) {
                      nodes {
                        id
                        fieldValues(first: 100) {
                          nodes {
                            ... on ProjectV2ItemFieldTextValue {
                              text
                              field {
                                ... on ProjectV2FieldCommon {
                                  name
                                }
                              }
                            }
                          }
                        }
                      }
                      pageInfo {
                        hasNextPage
                        endCursor
                      }
                    }
                  }
                }
              }
            `;
            
            try {
              let hasNextPage = true;
              let cursor = null;
              
              while (hasNextPage) {
                const variables = {
                  projectId: projectId,
                  first: 100,
                  after: cursor
                };
                
                const response = await client.request(query, variables);
                const items = response.node.items.nodes;
                
                for (const item of items) {
                  // Look for an item with a matching Story ID field
                  for (const fieldValue of item.fieldValues.nodes) {
                    if (fieldValue.field && fieldValue.field.name === 'Story ID' && fieldValue.text === storyId) {
                      console.log(`[find] Found existing item with matching Story ID: ${item.id}`);
                      return item.id;
                    }
                  }
                }
                
                const pageInfo = response.node.items.pageInfo;
                hasNextPage = pageInfo.hasNextPage;
                cursor = pageInfo.endCursor;
              }
              
              console.log(`[find] No existing item found with storyId: ${storyId}`);
              return null;
            } catch (error) {
              console.error(`[find] Error searching for existing item:`, error.message);
              return null;
            }
          }
          
          // Function to get project field IDs
          async function getProjectFields(client, projectId) {
            console.log(`[fields] Getting project fields for project: ${projectId}`);
            
            const query = gql`
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    fields(first: 100) {
                      nodes {
                        ... on ProjectV2Field {
                          id
                          name
                          dataType
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            try {
              const response = await client.request(query, { projectId });
              const fields = response.node.fields.nodes;
              
              // Create a map of field names to field IDs
              const fieldMap = {};
              fields.forEach(field => {
                fieldMap[field.name] = field.id;
              });
              
              console.log(`[fields] Retrieved ${fields.length} fields`);
              return fieldMap;
            } catch (error) {
              console.error(`[fields] Error getting project fields:`, error.message);
              return {};
            }
          }
          
          // Function to set additional fields on a newly created item
          async function setItemFields(client, projectId, itemId, storyData, storyId) {
            console.log(`[set-fields] Setting fields for item: ${itemId}`);
            
            // Get project field IDs
            const fieldIds = await getProjectFields(client, projectId);
            
            const updateItemMutation = gql`
              mutation($projectId: ID!, $fieldId: ID!, $itemId: ID!, $value: String!) {
                updateProjectV2ItemFieldValue(input: { projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: {text: $value} }) {
                  projectV2Item {
                    id
                  }
                }
              }
            `;
            
            try {
              // Set description
              if (fieldIds['Description']) {
                console.log(`[set-fields] Setting description for item: ${itemId}`);
                await client.request(updateItemMutation, {
                  projectId: projectId,
                  itemId: itemId,
                  fieldId: fieldIds['Description'],
                  value: storyData.description
                });
              }
              
              // Set acceptance criteria
              if (fieldIds['Acceptance Criteria']) {
                console.log(`[set-fields] Setting acceptance criteria for item: ${itemId}`);
                await client.request(updateItemMutation, {
                  projectId: projectId,
                  itemId: itemId,
                  fieldId: fieldIds['Acceptance Criteria'],
                  value: storyData.acceptanceCriteria.join('\n')
                });
              }
              
              // Set Story ID
              if (fieldIds['Story ID']) {
                console.log(`[set-fields] Setting Story ID (${storyId}) for item: ${itemId}`);
                await client.request(updateItemMutation, {
                  projectId: projectId,
                  itemId: itemId,
                  fieldId: fieldIds['Story ID'],
                  value: storyId
                });
              }
              
              // Set status to "Backlog"
              if (fieldIds['Status']) {
                console.log(`[set-fields] Setting status to Backlog for item: ${itemId}`);
                await client.request(updateItemMutation, {
                  projectId: projectId,
                  itemId: itemId,
                  fieldId: fieldIds['Status'],
                  value: 'Backlog'
                });
              }
              
              console.log(`[set-fields] Successfully set all fields for item: ${itemId}`);
            } catch (error) {
              console.error(`[set-fields] Error setting fields for item ${itemId}:`, error.message);
            }
          }
          
          // Function to update an existing project item
          async function updateProjectItem(client, projectId, itemId, storyData) {
            console.log(`[update] Updating existing item: ${itemId}`);
            
            // Get project field IDs
            const fieldIds = await getProjectFields(client, projectId);
            
            const updateItemMutation = gql`
              mutation($projectId: ID!, $fieldId: ID!, $itemId: ID!, $value: String!) {
                updateProjectV2ItemFieldValue(input: { projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: {text: $value} }) {
                  projectV2Item {
                    id
                  }
                }
              }
            `;
            
            try {
              // Update title (built-in field, doesn't need special handling)
              console.log(`[update] Updating title for item: ${itemId}`);
              await client.request(updateItemMutation, {
                projectId: projectId,
                itemId: itemId,
                fieldId: 'PFIELD_TITLE', // Title field ID
                value: storyData.title
              });
              
              // Update description field
              if (fieldIds['Description']) {
                console.log(`[update] Updating description for item: ${itemId}`);
                await client.request(updateItemMutation, {
                  projectId: projectId,
                  itemId: itemId,
                  fieldId: fieldIds['Description'],
                  value: storyData.description
                });
              }
              
              // Update acceptance criteria field
              if (fieldIds['Acceptance Criteria']) {
                console.log(`[update] Updating acceptance criteria for item: ${itemId}`);
                await client.request(updateItemMutation, {
                  projectId: projectId,
                  itemId: itemId,
                  fieldId: fieldIds['Acceptance Criteria'],
                  value: storyData.acceptanceCriteria.join('\n')
                });
              }
              
              // Update status to "Backlog"
              if (fieldIds['Status']) {
                console.log(`[update] Updating status to Backlog for item: ${itemId}`);
                await client.request(updateItemMutation, {
                  projectId: projectId,
                  itemId: itemId,
                  fieldId: fieldIds['Status'],
                  value: 'Backlog'
                });
              }
              
              console.log(`[update] Successfully updated item: ${itemId}`);
            } catch (error) {
              console.error(`[update] Error updating project item ${itemId}:`, error.message);
            }
          }
          
          // Function to create a new project item
          async function createProjectItem(client, projectId, storyData) {
            console.log(`[create] Creating new item with title: ${storyData.title}`);
            
            // First, create an issue to associate with the project item
            const createIssueMutation = gql`
              mutation($repositoryId: ID!, $title: String!, $body: String) {
                createIssue(input: { repositoryId: $repositoryId, title: $title, body: $body }) {
                  issue {
                    id
                  }
                }
              }
            `;
            
            try {
              // Get repository ID first
              const repoInfoQuery = gql`
                query($owner: String!, $name: String!) {
                  repository(owner: $owner, name: $name) {
                    id
                  }
                }
              `;
              
              const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
              const repoInfo = await client.request(repoInfoQuery, { owner, name: repo });
              const repositoryId = repoInfo.repository.id;
              
              // Create an issue for the story
              const issueResponse = await client.request(createIssueMutation, {
                repositoryId: repositoryId,
                title: storyData.title,
                body: storyData.description
              });
              
              const issueId = issueResponse.createIssue.issue.id;
              console.log(`[create] Created issue with ID: ${issueId}`);
              
              // Now add the issue to the project
              const addProjectItemMutation = gql`
                mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                    item {
                      id
                    }
                  }
                }
              `;
              
              const projectItemResponse = await client.request(addProjectItemMutation, {
                projectId: projectId,
                contentId: issueId
              });
              
              const newItemId = projectItemResponse.addProjectV2ItemById.item.id;
              console.log(`[create] Successfully created new project item with ID: ${newItemId}`);
              return newItemId;
            } catch (error) {
              console.error(`[create] Error creating project item:`, error.message);
              return null;
            }
          }
          
          // Main execution
          async function main() {
            console.log('[main] Starting main execution');
            const changedFilesRaw = process.env.CHANGED_FILES || '';
            console.log(`[main] CHANGED_FILES raw: "${changedFilesRaw}"`);
            const changedFiles = changedFilesRaw.split(' ').filter(Boolean);
            console.log(`[main] files count: ${changedFiles.length}`);
            const projectId = process.env.PROJECT_ID;
            console.log(`[main] projectId: ${projectId}`);
            
            if (!projectId) {
              console.error('[main] PROJECT_ID is not set');
              process.exit(1);
            }
            
            const client = new GraphQLClient('https://api.github.com/graphql', {
              headers: {
                authorization: `Bearer ${process.env.GITHUB_TOKEN}`
              }
            });
            
            for (const file of changedFiles) {
              if (file.endsWith('.md')) {
                try {
                  console.log(`[main] Processing file: ${file}`);
                  const storyData = parseStoryFile(file);
                  console.log(`[main] Parsed story data: title="${storyData.title}", storyId="${storyData.storyId}"`);
                  
                  // Check if an item with this story ID already exists
                  const existingItemId = await findExistingItem(client, projectId, storyData.storyId);
                  
                  if (existingItemId) {
                    // Update existing item
                    console.log(`[main] Updating existing item with ID: ${existingItemId}`);
                    await updateProjectItem(client, projectId, existingItemId, storyData);
                  } else {
                    // Create new item
                    console.log(`[main] Creating new item for story: ${storyData.title}`);
                    const newItemId = await createProjectItem(client, projectId, storyData);
                    if (newItemId) {
                      await setItemFields(client, projectId, newItemId, storyData, storyData.storyId);
                    }
                  }
                } catch (error) {
                  console.error(`[main] Error processing ${file}:`, error.message);
                }
              }
            }
            
            console.log('[main] Finished processing all files');
          }
          
          main().then(() => {
            console.log('[main] Script execution completed successfully');
          }).catch((error) => {
            console.error('[main] Script execution failed:', error.message);
            process.exit(1);
          });
          EOF

          # Execute the script with required environment variables
          echo "[DEBUG] Executing Node.js script" >> create-project-stories.log
          node create-project-items.cjs 2>&1 | tee -a create-project-stories.log | tee ./artifacts/run.log
          echo "[DEBUG] Node.js script execution completed" >> create-project-stories.log
          
          # Copy script to artifacts
          cp create-project-items.cjs ./artifacts/
          echo "Logs uploaded to artifacts directory" > ./artifacts/artifact-info.txt
          echo "Changed files: $CHANGED_FILES" >> ./artifacts/artifact-info.txt
          
          echo "Artifacts ready in ./artifacts"

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: Create-GitHub-Project-Stories-${{ github.run_number }}
          path: |
            create-project-stories.log
            ./artifacts
          if-no-files-found: warn
          retention-days: 7